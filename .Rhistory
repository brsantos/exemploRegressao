SORTrandom.res<-array(dim=c(N,repl))
for(k in 1:repl) {SORTrandom.res[,k]<-sort(ABSrandom.res[,k])}
descritiva<-array(dim=c(N,3))
for(k in 1:N) {	descritiva[k,1]<-min(SORTrandom.res[k,])
descritiva[k,2]<-median(SORTrandom.res[k,])
descritiva[k,3]<-max(SORTrandom.res[k,])}
Z<-array(dim=c(N,1))
for(i in 1:N)   {Z[i]<-qnorm((i+N-1/8)/(2*N+1/2))}
final<-cbind(Z,descritiva,SORTorig.res)
faixa <- range(final[,5],final[,2],final[,4])
if (opcaoEnvelope=="Meio-normal")
{
par(mfrow=c(1,1))
par(pty="s")
plot(final[,1],final[,5],xlab="Valor Esperado da Estatistica de Ordem Meio-Normal",
ylab="Valor Absoluto Ordenado do Residuo Padronizado", ylim=faixa, pch=16)
par(new=T)
#
lines(final[,1],final[,2])
lines(final[,1],final[,3],lty=2)
lines(final[,1],final[,4])
}
if (opcaoEnvelope=="Normal")
{
par(pty="s")
qqnorm(final[,5],xlab="Percentis da N(0,1)",
ylab="Residuo de Pearson Padronizado", ylim=faixa, pch=16)
par(new=T)
#
qqnorm(final[,2],axes=F,xlab="",ylab="",type="l",ylim=faixa,lty=1)
par(new=T)
qqnorm(final[,4],axes=F,xlab="",ylab="", type="l",ylim=faixa,lty=1)
par(new=T)
qqnorm(final[,3],axes=F,xlab="", ylab="", type="l",ylim=faixa,lty=2)
}
}
envelope_gee_gama(ajuste.gross, gross, analise_diag_gross, opcaoEnvelope="Normal")
envelope_gee_gama(fit.model.rinse1, rinse1, analise_diag_rinse, opcaoEnvelope="Normal")
17*16
envelope_gee_gama(ajuste.gross, gross, analise_diag_gross, opcaoEnvelope="Normal")
#####################################################################################
# PROGRAMA PARA GERAR ENVELOPE EM REGRESSAO GAMA COM ESTRUTURA DE CORRELA??O  	    #
#####################################################################################
#										    #
#  Descri??o dos argumentos da fun??o:						    #
#  - modelo = objeto do tipo gee(Y~X, family=Gamma(link=log), ...) 		    #
#  - dados = banco de dados utilizado no ajuste do modelo			    #
#  - diag_gama = objeto gerado a partir da fun??o diag_gee_gama	                    #
#  - opcaoEnvelope = caso op??o seja "Normal", ent?o ser? gerado o envelope 	    #
#		     normal. Caso o interesse seja analisar o meio-normal, ent?o    #
#		     op??o deve ser "Meio-normal".				    #
#										    #
#####################################################################################
envelope_gee_gama <- function(modelo, dados, diag_gama, opcaoEnvelope="Normal")
{
X <- model.matrix(as.formula(paste("~ ", modelo$call$formula[3])), dados)
y <- modelo$y
beta <- coef(modelo)
R <- modelo$work
mi <- fitted(modelo)
individuo <- modelo$id
estrutura.cor <- modelo$call$corstr
repet <- dim(modelo$work)[1]
ue <- modelo$nobs/repet
N <- nrow(X)
p <- ncol(X)
#########################
# GERAR VARIAVEIS GAMMA #
#########################
repl <- 25  #Numero de replicas indico por Tan, Qu and Kutner
random.y<-array(dim=c(N,repl))
mi.fit <- matrix(fitted(modelo),ue,byrow=T)
indice<-matrix(c(1:repet),repet,repet,byrow=T)
cont<-1
for (i in 1:ue)
{
cat("i=",i,"\n")
flag<-T
k<-0
TS<-matrix(c(1:repet),repet)
gama<-0
media<-mi.fit[i,]
lambda<-sqrt(diag(media))%*%R%*%sqrt(diag(media))
lambda<-round(lambda,6)
cat('lambda = ', sort(lambda), '\n')
while (flag)
{
k<-k+1
gama.min<-min(lambda[lambda>0])
cat('k = ', k, '\n')
cat('lambda = ', sort(lambda), '\n')
#     cat('gama.min = ', gama.min, '\n')
rs <- indice[lambda==gama.min]
S <- unique(rs)
#     cat('S = ', S, '\n')
for (j in 1:length(S))
for (l in j:length(S)) {
#         cat('length(S) = ', length(S), '\n')
#         cat('i = ', i, '\n')
#         cat('j = ', j, '\n')
#         cat('gama.min = ', gama.min, '\n')
#         cat('lambda[S[j],S[l]] = ', lambda[S[j],S[l]], '\n')
#
if (lambda[S[j],S[l]]==gama.min) rs<-c(S[j],S[l])
}
S <- sort(unique(rs))
for (j in 1:repet)
if (all(lambda[j,S]>0)) S <- c(S,j)
S <- sort(unique(S))
for (j in 1:length(S))
for (l in 1:length(S))
lambda[S[j],S[l]] <- lambda[S[j],S[l]]-gama.min
ts <- rep(0,repet)
for (j in 1:repet)
if (is.element(j,S)) ts[j] <- 1
TS <- cbind(TS,ts)
gama <- c(gama,gama.min)
#     cat('lambda = ', sort(lambda), '\n')
if (all(lambda<=0)) flag <- F
}
TS <- TS[,-1]
gama <- gama[-1]
m <- k
for(j in 1:repl)
{
x <- rpois(1,gama[1])
for (k in 2:m) x <- cbind(x,rgamma(1,diag_gama$phi,diag_gama$phi*1/gama[k]))
U <- TS%*%t(x)
random.y[cont:(cont+repet-1),j] <- U
}
cont<-cont+repet
}
#########################################
# ENVELOPE SIMULADO PARA REGRESSAO GAMA #
#########################################
orig.res<-diag_gama$ResPadronizado
if (opcaoEnvelope=="Meio-normal") ABSorig.res <- abs(orig.res)
if (opcaoEnvelope=="Normal") ABSorig.res <- orig.res
SORTorig.res<-sort(ABSorig.res)
dados2<-cbind(dados,random.y)
random.res<-array(dim=c(N,repl))
cat("A simulacao acaba quando k for ",repl,"\n")
for(k in 1:repl)
{
cat("k:",k,"\n")
temp.gee.all<-gee(as.formula(paste("random.y[,k] ~ ", modelo$call$formula[3])),
id=individuo, family=Gamma(link=log),
data = dados2, corstr=estrutura.cor)
y <- temp.gee.all$y
beta <- coef(temp.gee.all)
cat("beta:",beta,"\n")
R <- temp.gee.all$work
mi <- fitted(temp.gee.all)
#Calculo do Residuo de Pearson
r<-(y-mi)*(1/sqrt(mi^2))
#Calculo de phi
invphi<-as.numeric(sum(r^2)/(N-p))
phi<-1/invphi
#Matriz C <- A * Delta	#Ligacao canonica -> Delta=Identidade
A <- diag(mi^2,N)
Delta <- diag(1/mi,N)
C <- Delta%*%A
#Matriz Omega - variancia e covariancia de y
Omega <- matrix(0,N,N)
invOmega <- matrix(0,N,N)
l <- 1
while (l<N)
{
Omega[l:(l+repet-1),l:(l+repet-1)] <- sqrt(A[l:(l+repet-1),l:(l+repet-1)])%*%R%*%sqrt(A[l:(l+repet-1),l:(l+repet-1)])
invOmega[l:(l+repet-1),l:(l+repet-1)] <-solve(Omega[l:(l+repet-1),l:(l+repet-1)])
l <- l+repet
}
Omega <- invphi*Omega
invOmega <- phi*invOmega
#Matriz H e W
W <- C%*%invOmega%*%C
H <- solve(t(X)%*%W%*%X)
raizW <- matrix(0,N,N)
l <- 1
while (l<N)
{
auto<-eigen(W[l:(l+repet-1),l:(l+repet-1)])
raizW[l:(l+repet-1),l:(l+repet-1)] <- auto$vectors%*%sqrt(diag(auto$values))%*%t(auto$vectors)
l <- l+repet
}
H <- raizW%*%X%*%H%*%t(X)%*%raizW
h <- diag(H)
random.rsd <- as.vector(rep(0,N))
part.rsd <- raizW%*%solve(C)%*%(y-mi)
for (l in 1:N)
{
e <- as.vector(rep(0,N))
e[l] <- 1
random.rsd[l] <- t(e)%*%part.rsd*sqrt(1/(1-h[l]))
}
random.res[,k]<-random.rsd
}
if (opcaoEnvelope=="Meio-normal") ABSrandom.res<-abs(random.res)
if (opcaoEnvelope=="Normal") ABSrandom.res<-random.res
SORTrandom.res<-array(dim=c(N,repl))
for(k in 1:repl) {SORTrandom.res[,k]<-sort(ABSrandom.res[,k])}
descritiva<-array(dim=c(N,3))
for(k in 1:N) {	descritiva[k,1]<-min(SORTrandom.res[k,])
descritiva[k,2]<-median(SORTrandom.res[k,])
descritiva[k,3]<-max(SORTrandom.res[k,])}
Z<-array(dim=c(N,1))
for(i in 1:N)   {Z[i]<-qnorm((i+N-1/8)/(2*N+1/2))}
final<-cbind(Z,descritiva,SORTorig.res)
faixa <- range(final[,5],final[,2],final[,4])
if (opcaoEnvelope=="Meio-normal")
{
par(mfrow=c(1,1))
par(pty="s")
plot(final[,1],final[,5],xlab="Valor Esperado da Estatistica de Ordem Meio-Normal",
ylab="Valor Absoluto Ordenado do Residuo Padronizado", ylim=faixa, pch=16)
par(new=T)
#
lines(final[,1],final[,2])
lines(final[,1],final[,3],lty=2)
lines(final[,1],final[,4])
}
if (opcaoEnvelope=="Normal")
{
par(pty="s")
qqnorm(final[,5],xlab="Percentis da N(0,1)",
ylab="Residuo de Pearson Padronizado", ylim=faixa, pch=16)
par(new=T)
#
qqnorm(final[,2],axes=F,xlab="",ylab="",type="l",ylim=faixa,lty=1)
par(new=T)
qqnorm(final[,4],axes=F,xlab="",ylab="", type="l",ylim=faixa,lty=1)
par(new=T)
qqnorm(final[,3],axes=F,xlab="", ylab="", type="l",ylim=faixa,lty=2)
}
}
envelope_gee_gama(ajuste.gross, gross, analise_diag_gross, opcaoEnvelope="Normal")
17*17
17*17/2
17*17 - 17
(17*17 - 17)/2
(17*17 - 17)/2 + 17
polya_urn_model = function(base_color_distribution, num_balls, alpha) {
balls = c()
for (i in 1:num_balls) {
if (runif(1) < alpha / (alpha + length(balls))) {
# Add a new ball color.
new_color = base_color_distribution()
balls = c(balls, new_color)
} else {
# Pick out a ball from the urn, and add back a
# ball of the same color.
ball = balls[sample(1:length(balls), 1)]
balls = c(balls, ball)
}
}
balls
}
stick_breaking_process = function(num_weights, alpha) {
betas = rbeta(num_weights, 1, alpha)
remaining_stick_lengths = c(1, cumprod(1 - betas))[1:num_weights]
weights = remaining_stick_lengths * betas
weights
}
stick_breaking_process(10, 1)
stick_breaking_process(10, 1)
library(ggplot2)
?bar_plot
library(ggplot2)
plotStick <- function(num_weights, alpha){
a <- stick_breaking_process(num_weights, alpha)
b <- stick_breaking_process(num_weights, alpha)
c <- stick_breaking_process(num_weights, alpha)
g <- ggplot(data.frame(y=c(a,b,c), x=rep(1:num_weights, 3),
group=rep(1:3, each=num_weights)), aes(x=x,y=y))
g + geom_bar(stat='identity') + facet_wrap(~group)
}
plotStick(10,1)
plotStick(10,2)
plotStick(10,10)
plotStick(10,0.1)
plotStick(10,0.5)
plotStick(10,1)
plotStick(10,1)
library(RJDBC)
library(doBy)
library(multicore)
drv <- JDBC("com.microsoft.sqlserver.jdbc.SQLServerDriver", "/home/bruno/Downloads/sqljdbc_4.0/enu/sqljdbc4.jar")
conn <- dbConnect(drv, "jdbc:sqlserver://200.144.255.200", "ello", "ello@cloud&")
conn <- dbConnect(drv, "jdbc:sqlserver://200.144.255.200", "ello", "ello@cloud&*")
dbListTables(conn)
dbGetTables(conn)
subset(dbGetTables(conn), TABLE_SCHEM!='sys')
subset(dbGetTables(conn), TABLE_SCHEM=='LEGISLATIVO')
subset(dbGetTables(conn), TABLE_SCHEM=='LEGISLATIVO')
drv <- JDBC("com.microsoft.sqlserver.jdbc.SQLServerDriver", "/home/bruno/Downloads/sqljdbc_4.0/enu/sqljdbc4.jar")
conn <- dbConnect(drv, "jdbc:sqlserver://200.144.255.200", "ello", "ello@cloud&*")
subset(dbGetTables(conn), TABLE_SCHEM=='LEGISLATIVO')
sqlDicNomes <- paste("SELECT * FROM  tbl_Parlamentares_X_DicNomes", sep="")
tabelaOrigem <- dbGetQuery(conn, sqlDicNomes)
sqlMovPart <- paste("SELECT * FROM  tbl_Parlamentares_X_MovPart", sep="")
tabelaOrigem <- dbGetQuery(conn, sqlMovPart)
drv <- JDBC("com.microsoft.sqlserver.jdbc.SQLServerDriver", "/home/bruno/Downloads/sqljdbc_4.0/enu/sqljdbc4.jar")
conn <- dbConnect(drv, "jdbc:sqlserver://200.144.255.200", "ello", "ello@cloud&*")
library(RJDBC)
library(doBy)
library(multicore)
drv <- JDBC("com.microsoft.sqlserver.jdbc.SQLServerDriver", "/home/bruno/Downloads/sqljdbc_4.0/enu/sqljdbc4.jar")
conn <- dbConnect(drv, "jdbc:sqlserver://200.144.255.200", "ello", "ello@cloud&*")
subset(dbGetTables(conn), TABLE_SCHEM=='LEGISLATIVO')
sqlDicNomes <- paste("SELECT * FROM  tbl_Parlamentares_X_DicNomes", sep="")
tabelaDicNomes <- dbGetQuery(conn, sqlDicNomes)
sqlDicNomes <- paste("SELECT * FROM  counts", sep="")
tabelaDicNomes <- dbGetQuery(conn, sqlDicNomes)
sqlDicNomes <- paste("SELECT * FROM  vw_votos_2013", sep="")
tabelaDicNomes <- dbGetQuery(conn, sqlDicNomes)
conn <- odbcConnectAccess(drv, "jdbc:sqlserver://200.144.255.200", "ello", "ello@cloud&*")
sqlDicNomes <- paste('SELECT * FROM  tbl_Parlamentares_X_MovPart', sep="")
tabelaDicNomes <- dbGetQuery(conn, sqlDicNomes)
tabelaDicNomes <- dbReadTable(conn, obj='tbl_Parlamentares_X_MovPart')
tabelaDicNomes <- dbReadTable(conn, name='tbl_Parlamentares_X_MovPart')
tabelaDicNomes <- dbReadTable(conn, name=tbl_Parlamentares_X_MovPart)
4(1.000^2)
4x(1.000^2)
2x4
4*(1.000^2)
4*(1000^2)
2000^2
pnorm(1)-pnorm(0.5)
(pnorm(1)-pnorm(0.5))/pnorm(1)
(pnorm(1)-pnorm(0.5))/(1-pnorm(0.5))
pnorm(1)-pnorm(0.5)
1-pnorm(0.5)
pnorm(0.5)
pbinomial(4,3, pnorm(0.5))
pbinom(4,3, pnorm(0.5))
?pbinom
pbinom(3,4,pnorm(0.5))
pbinom(4,4,pnorm(0.5))
dbinom(3,4,pnorm(0.5))
dbinom(4,4,pnorm(0.5))
dbinom(3,4,pnorm(0.5))+dbinom(4,4,pnorm(0.5))
qnorm(0.95)
(qnorm(0.95)*2.000) + 48000
(qnorm(0.95)*2000) + 48000
(1.64*2000) + 48000
qnorm(0.995)
library(RJDBC)
library(doBy)
library(multicore)
drv <- JDBC("com.microsoft.sqlserver.jdbc.SQLServerDriver", "/home/bruno/Downloads/sqljdbc_4.0/enu/sqljdbc4.jar")
conn <- dbConnect(drv, "jdbc:sqlserver://200.144.255.200", "ello", "ello@cloud&*")
library(RODBC)
install.packages('RODBC', dep=T)
library(RODBC)
install.packages('RMySQL', dep=T)
library(RMySQL)
?dbConnect
mychannel <- dbConnect(MySQL(), user="ello", password="ello@cloud&*", host="200.144.255.200")
?dbConnect
?RJDBC::dbConnect
?RJDBC:dbConnect
library(RJDBC)
?dbConnect
drv <- JDBC("com.microsoft.sqlserver.jdbc.SQLServerDriver", "/home/bruno/Downloads/sqljdbc_4.0/enu/sqljdbc4.jar")
conn <- dbConnect(drv, "jdbc:sqlserver://200.144.255.200", "ello", "ello@cloud&*")
library(RMySQL)
mychannel <- dbConnect(MySQL(), user="ello", password="ello@cloud&*", host="200.144.255.200", port=1433)
mychannel <- dbConnect(RSQLite::SQLite(), user="ello", password="ello@cloud&*", host="200.144.255.200", port=1433)
install.packages('RSQLite', dep=T)
mychannel <- dbConnect(RSQLite::SQLite(), user="ello", password="ello@cloud&*", host="200.144.255.200", port=1433)
library(RSQLite)
mychannel <- dbConnect(SQLite(), user="ello", password="ello@cloud&*", host="200.144.255.200", port=1433)
mychannel <- dbConnect(dbDriver("MySQL"), user="ello", password="ello@cloud&*", host="200.144.255.200", port=1433)
Rcpp::sourceCpp('Dropbox/Pós Graduação/Doutorado/Tese/Programas/ProgramasC++/ZItobitBayesQR.cpp')
set.seed(1)
n <- 500
x1 <- runif(n)
x2 <- runif(n)
alpha <- 0
beta1 <- 10
beta2 <- -10
prob <- exp(alpha+beta1*x1+beta2*x2)/(1+exp(alpha+beta1*x1+beta2*x2))
ind <- runif(n) < prob
sum(ind)
y <- rep(0, n)
yQR <- rnorm(n - sum(ind), 2-2.5*x2[!ind], 0.5)
plot(density(yQR))
sum(yQR < 0)
plot(x2[!ind], yQR)
y[!ind] <- yQR
y2 <- y[order(y)]
# Primeiros 89 censurados
y2 <- ifelse(y2 < 0, 0, y2)
X <- cbind(1, x1, x2)
ind2 <- as.numeric(ind[order(y)])
X2 <- X[order(y), ]
init.betaZero <- coef(glm(ind2~X2-1,family=binomial))
n.iter <- 1e5
modelo <- ziTobitBayesQR(0.5, y2, X2, n.iter, 1, rep(0, ncol(X)), 0.5, init.betaZero, 2, "logit", 0)
Rcpp::sourceCpp('Dropbox/Pós Graduação/Doutorado/Tese/Programas/ProgramasC++/ZItobitBayesQR.cpp')
modelo <- ziTobitBayesQR(0.5, y2, X2, n.iter, 1, rep(0, ncol(X)), 0.5, init.betaZero, 2, "logit", 0)
Rcpp::sourceCpp('Dropbox/Pós Graduação/Doutorado/Tese/Programas/ProgramasC++/ZItobitBayesQR.cpp')
modelo <- ziTobitBayesQR(0.5, y2, X2, n.iter, 1, rep(0, ncol(X)), 0.5, init.betaZero, 2, "logit", 0)
Rcpp::sourceCpp('Dropbox/Pós Graduação/Doutorado/Tese/Programas/ProgramasC++/ZItobitBayesQR.cpp')
Rcpp::sourceCpp('Dropbox/Pós Graduação/Doutorado/Tese/Programas/ProgramasC++/ZItobitBayesQR.cpp')
Rcpp::sourceCpp('Dropbox/Pós Graduação/Doutorado/Tese/Programas/ProgramasC++/ZItobitBayesQR.cpp')
Rcpp::sourceCpp('Dropbox/Pós Graduação/Doutorado/Tese/Programas/ProgramasC++/ZItobitBayesQR.cpp')
modelo <- ziTobitBayesQR(0.5, y2, X2, n.iter, 1, rep(0, ncol(X)), 0.5, init.betaZero, 2, "logit", 0)
Rcpp::sourceCpp('Dropbox/Pós Graduação/Doutorado/Tese/Programas/ProgramasC++/ZItobitBayesQR.cpp')
modelo <- ziTobitBayesQR(0.5, y2, X2, n.iter, 1, rep(0, ncol(X)), 0.5, init.betaZero, 2, "logit", 0)
Rcpp::sourceCpp('Dropbox/Pós Graduação/Doutorado/Tese/Programas/ProgramasC++/ZItobitBayesQR.cpp')
library(Rcpp)
Sys.setenv("PKG_CXXFLAGS"="-fopenmp")
Sys.setenv("PKG_LIBS"="-fopenmp")
code='
#ifdef _OPENMP
#include <omp.h>
#endif
// [[Rcpp::depends(RcppProgress)]]
#include <progress.hpp>
// [[Rcpp::export]]
double long_computation_omp2(int nb, int threads=1) {
#ifdef _OPENMP
if ( threads > 0 )
omp_set_num_threads( threads );
REprintf("Number of threads=%i\\n", omp_get_max_threads());
#endif
Progress p(nb, true);
double sum = 0;
#pragma omp parallel for schedule(dynamic)
for (int i = 0; i < nb; ++i) {
double thread_sum = 0;
if ( ! Progress::check_abort() ) {
p.increment(); // update progress
for (int j = 0; j < nb; ++j) {
thread_sum += R::dlnorm(i+j, 0.0, 1.0, 0);
}
}
sum += thread_sum;
}
return sum + nb;
}
'
sourceCpp(code=code)
s <- long_computation_omp2(10000, 4)
s <- long_computation_omp2(10000, 2)
s <- long_computation_omp2(10000, 1)
s <- long_computation_omp2(10000, 4)
plot(dpois(0:10, 2))
?plot
plot(dpois(0:10, 2), type="h")
plot(dpois(0:10, 4), type="h")
plot(dpois(0:10, 5), type="h")
3104*1.05
3104*1.06
3104*1.1
library(RSQLite)
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
library(ggvis)
install.packages('ggvis', dep=T)
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
a <- rnorm(20)
b <- rnorm(20)
names(lm(a~b))
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
library(dplyr)
?sort
order(a )
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shinyUI(pageWithSidebar(
headerPanel("Example"),
sidebarPanel(
),
mainPanel(
tabsetPanel(tabPanel("Main",plotOutput("temp", height = 1000, width = 1000))
)#tabsetPanel
)#mainPane;
))
shinyServer(function(input, output) {
output$temp <-renderPlot({
par(mfrow=c(2,2))
plot(1:10)
plot(rnorm(10))
plot(rnorm(10))
plot(rnorm(10))
})
})
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
shiny::runApp('SpiderOak Hive/Pós Graduação/Monitoria/PAE/Analise de Regressão/exemploRegressao')
